<html>
    <head>
        <meta charset="UTF-8" />
    
        <title>Pro-Ana Communities</title>

        <link rel="stylesheet" type="text/css" href="css/normalize.css">
        <link rel="stylesheet" type="text/css" href="css/skeleton.css">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto Mono">

        <style>
            body {
                margin: 1in;
                font-family: 'Roboto Mono', sans-serif;
            }
            #layout {
                display: inline-flex;
                flex-wrap: wrap ;
            }
            .card {
                width: 400px;
                padding: 1em;
                margin: 1em;
                box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
                border-radius: 5px;
            }
            .collapsible {
                background-color: #eee;
                color: #444;
                cursor: pointer;
                width: 100%;
                border: none;
                text-align: left;
                outline: none;
                font-size: 15px;
                padding: 0 0.5em;
            }
            .active, .collapsible:hover {
                background-color: #ccc;
            }
            .content {
                display: none;
                overflow: hidden;
                background-color: #f1f1f1;
                margin-bottom: 1em;
                padding: 0.5em;
            }
            .collapsible:after {
                content: '\2304'; 
                font-size: 30px;
                color: #444;
                float: right;
                margin-left: 5px;
                line-height: 0.6em;
            }

            .active:after {
                content: "\2303"; 
                line-height: 1.6em;
            }
            #card-title{
                /* height: 70px; */
                font-size: 22px;
            }
            #card-footer {
                margin: 1em 0;
            }
        </style>

        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://unpkg.com/d3-force-cluster@latest"></script>
    </head>
<body>
    <div id="layout">
        <div id="topic-0" class="container card">
            <div class="row">
                <h4 id="card-title">
                    ....
                </h4>
            </div>

            <div class="row" id="card-details">
                <p>Topic description here</p>
            </div>

            <!-- collapse: https://www.w3schools.com/howto/howto_js_collapsible.asp -->

            <div class="row" id="collapse">
                <button type="button" class="collapsible">See Top Words</button>
                <div class="content">
                    <p>Top words here...</p>
                    <svg id="topwords" width="355" height="200" style="border: 1px solid black; background-color:white"></svg>
                </div>
            </div>

            <div class="row" id="chart">
                <svg id="main" width="370" height="300" style="border: 1px solid black"></svg>
            </div>

            <div class="row" id="card-footer">
                <p>FOOTER CONTENT HERE</p>
            </div>
        </div>
    </div>

    <script>


    const requestData = async () => {
        full = await d3.csv("data/full_data.csv", d3.autoType)
        topWords = await d3.csv("data/top-words.csv", d3.autoType)
        
        console.log(full);
        console.log(topWords)

        // store cols w topic scores
        const topCol = new Array
        full.columns.forEach(d => {
            if(d.includes("topic")){
                topCol.push(d)
            }
        })

        // store data for scaling radius
        const radData = {'min': 1,
                        'max': 0,}

        topCol.forEach((top) => {

            var top0 = full.filter(function (d) {

                return d.dom_top === top;

            })

            // sort by group 
            let groups = d3.groups(top0, o => o.class)

            let sortedGroups = new Array

            groups.forEach((g) => {
                sortedGroups.push(g[1].sort(function (a, b) { return -a[top] - -b[top] })
                    .slice(0, 20))
            })

            let mergedGr = d3.merge(sortedGroups)

            let min = d3.min(mergedGr, d => d[top])
            let max = d3.max(mergedGr, d => d[top])

            if (radData['min']> min) radData['min']=min;
            if (radData['max']< max) radData['max']=max;

        })

        console.log(radData)
        
        // dict for text
        let textMap = {"topic-0": "TOPIC 1: DIET FOODS",
                       "topic-1": "TOPIC 2: SHAME FROM AN ED",
                       "topic-2": "TOPIC 3: SUPPORT AND EMPATHY",
                       "topic-3": "TOPIC 4: RECOVERY",
                       "topic-4": "TOPIC 5: LIVING WITH AN ED",
                       "topic-5": "TOPIC 6: HATRED OF BODY",
                       "topic-6": "TOPIC 7: CALORIE RESTRICTION",
                       "topic-7": "TOPIC 8: FEELING HUNGRY",
                       "topic-8": "TOPIC 9: TRIGGERS",
                       "topic-9": "TOPIC 10: GOAL WEIGHTS"
        }

        let chosenTopic = "topic-0"

        function updateText(chosenTopic){
            let cont = d3.select(`div#${chosenTopic}`)
            cont.select("h4#card-title").text(textMap[chosenTopic])
        }


        function populateCard(chosenTopic, svg, topW) {

            let width = svg.attr("width")
            let height = svg.attr("height")
            const margins = { top: 10, right: 15, bottom: 30, left: 60 }
            const chartWidth = width - 10 - margins.right;
            const chartHeight = height - margins.top - 10;

            const topWidth = topW.attr("width")
            const topHeight = topW.attr("height")
            const topChartWidth = topWidth - margins.left - margins.right;
            const topChartHeight = topHeight - margins.top - margins.bottom;

            // see top words collapsible 
            let cont = d3.select(`div#${chosenTopic}`)
            let coll = cont.select("button.collapsible");
            coll.on("click", function () {
                this.classList.toggle("active");
                var content = cont.select("div.content")
                if (content.style("display") === "block") {
                    content.style("display", "none");
                    content.select("g#bars").remove()
                    
                } else {
                    content.style("display", "block");
                    loadBars();
                }

            });

            function loadBars(){
                // top words
                const wordArea = topW.append("g").attr("id", "bars")
                    .attr("transform", `translate(${margins.left}, ${margins.top})`)

                // Y axis
                let selectWords = topWords.filter(function (d) {
                    let top = parseInt(chosenTopic.slice(-1))
                    return d.topic == top
                })
                var y = d3.scaleBand()
                    .range([0, topChartHeight])
                    .domain(selectWords.map(function (d) { return d.word; }))
                    .padding(0.2);
                wordArea.append("g")
                    .call(d3.axisLeft(y).tickSize(0))
                    .selectAll("text")
                    // .attr("transform", "translate(-10,0)rotate(-45)")
                    .style("text-anchor", "end");

                // Add X axis
                var xExtent = d3.extent(selectWords, d => d['proba'])
                var x = d3.scaleLinear()
                    .domain([0, xExtent[1]])
                    .range([0, topChartWidth]);
                wordArea.append("g")
                    .attr("transform", "translate(0," + topChartHeight + ")")
                    .call(d3.axisBottom(x)
                        .ticks(4)
                        .tickSize(0)
                        .tickFormat(d3.format(".1%")));

                // color scale
                var barColor = d3.scaleSequential(d3.interpolateOrRd)
                    .domain(xExtent)

                // set font
                d3.selectAll("text").attr("font-family", "Roboto Mono")


                wordArea.selectAll("rects").data(selectWords)
                    .join("rect")
                    .attr("y", d => y(d['word']))
                    .attr("height", y.bandwidth())
                    .transition() // <---- Here is the transition
                    .duration(1000)
                    .attr("width", d => topChartWidth - y(d['word']))
                    .attr("x", d => x(0))
                    .attr("fill", d => barColor(d['proba']))

            }
            

            // update title and desc
            updateText(chosenTopic)

            var top0 = full.filter(function (d) {

                return d.dom_top === chosenTopic;

            })

            // sort by group 
            let groups = d3.groups(top0, o => o.class)

            let sortedGroups = new Array

            groups.forEach((g) => {
                sortedGroups.push(g[1].sort(function (a, b) { return -a[chosenTopic] - -b[chosenTopic] })
                    .slice(0, 20))
            })

            let mergedGr = d3.merge(sortedGroups)

            // d3 force cluster from https://gist.github.com/ericsoco/4e1b7b628771ae77753842e6dabfcef3

            var padding = 1.5, // separation between same-color nodes
                clusterPadding = 10, // separation between different-color nodes
                maxRadius = 13;

            var n = mergedGr.length, // total number of nodes
                m = 3; // number of distinct clusters

            var color = d3.scaleOrdinal()
                .domain(['edc', 'mpa', 'reddit'])
                .range(["cornflowerblue", "coral", "crimson"]);

            // The largest node for each cluster.
            var clusters = new Array(m);

            var nodesTest = new Array

            // new scale for radius
            var radExtent = [radData['min'], radData['max']]
            // const radExtent = d3.extent(mergedGr, d => d[chosenTopic])
            const radScale = d3.scaleSqrt().domain(radExtent).range([5, maxRadius])

            var mapping = { "edc": 1, "mpa": 2, "reddit": 3 }

            function getText(d) {
                return d.class != "reddit" ? d['post-text'] : d['body']
            }

            mergedGr.forEach(function (d) {
                var i = d['class'],
                    r = radScale(d[chosenTopic]),
                    d = {
                        cluster: i,
                        radius: r,
                        text: getText(d),
                        x: Math.cos(mapping[i] / m * 0.7 * Math.PI) * 140 + chartWidth / 2 ,
                        y: Math.sin(mapping[i] / m * 0.7 * Math.PI) * 140 + chartHeight / 2 
                    };
                if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
                nodesTest.push(d);
            })
            
            var simulation = d3.forceSimulation()
                // keep entire simulation balanced around screen center
                .force('center', d3.forceCenter(width / 2, height / 2))

                // cluster by section
                .force('cluster', d3.forceCluster()
                    .centers(function (d) { return clusters[d.cluster]; })
                    .strength(0.5))

                // apply collision with padding
                .force('collide', d3.forceCollide(function (d) { return d.radius + padding; }))

                .on('tick', layoutTick)
                .nodes(nodesTest);

            const chartArea = svg.append("g").attr("id", "force");

            var node = chartArea.selectAll('circle')
                .data(nodesTest)
                .enter().append('circle')
                .style('fill', d => color(d.cluster))
                .on("mouseover", hoverIn)
                .on("mouseout", hoverOut)
                .on("click", mouseClick);

            function layoutTick(e) {
                node
                    .attr('cx', function (d) { return d.x; })
                    .attr('cy', function (d) { return d.y; })
                    .attr('r', function (d) { return d.radius; });
            }

            

        }
        populateCard(chosenTopic, d3.select("svg#main"), d3.select("svg#topwords"));


        topCol.slice(1).forEach(t => {

            // test html function
            let cont = d3.select("div#layout")
                .append("div")
                .attr("id", t)
                .attr("class", "container card")
                

            cont.html('<div class="row"><h4 id="card-title">....</h4></div>' +
                '<div class="row" id="card-details"><p>Topic description here</p></div>' +
                '<div class="row" id="collapse"><button type = "button" class= "collapsible">See Top Words</button>' +
                '<div class="content"><p>Top words here...</p><svg id="topwords" width="355" height="200" style="border: 1px solid black; background-color:white"></svg></div></div >' +
                '<div class="row" id="chart"><svg id = "main" width = "370" height = "300" style = "border: 1px solid black"></svg></div >' +
                '<div class="row" id="card-footer"><p>FOOTER CONTENT HERE</p></div>')
            
            populateCard(t, cont.select("svg#main"), cont.select("svg#topwords"))

        })
        


        function hoverIn(){
            d3.select(this).style("stroke", "black").style("stroke-width", 2)
        }

        function hoverOut(){
            d3.select(this).style("stroke", "")
        }

        function mouseClick(e,d){
            console.log(d.text)
        }

        



    }
    requestData();
    </script>
</body>
</html>
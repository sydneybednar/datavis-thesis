<html>
    <head>
        <meta charset="UTF-8" />
    
        <title>Pro-Ana Communities</title>

        <link rel="stylesheet" type="text/css" href="css/normalize.css">
        <link rel="stylesheet" type="text/css" href="css/skeleton.css">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto Mono">

        <style>
            body {
                margin: 1in;
                font-family: 'Roboto Mono', sans-serif;
            }
            #scrolly {
                position: relative;
                display: -webkit-box;
                display: -ms-flexbox;
                display: flex;
                padding: 1rem;
		    }
            #scrolly>* {
                -webkit-box-flex: 1;
                -ms-flex: 1;
                flex: 1;
            }

            article {
                position: relative;
                max-width: 40rem;
            }

            figure {
                position: -webkit-sticky;
                position: sticky;
                margin: 0;
                -webkit-transform: translate3d(0, 0, 0);
                -moz-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
                z-index: 0;
            }

            figure p {
                text-align: center;
                padding: 1rem;
                position: absolute;
                top: 50%;
                left: 50%;
                -moz-transform: translate(-50%, -50%);
                -webkit-transform: translate(-50%, -50%);
                transform: translate(-50%, -50%);
                font-size: 8rem;
                font-weight: 900;
                color: #fff;
            }

            .step {
                margin: 0 auto 2rem auto;
                background-color: #f8f8f8;
                color: rgb(0, 0, 0);
            }

            .step:last-child {
                margin-bottom: 0;
            }

            .step.is-active {
                /* background-color: rgb(106, 181, 246); */
                color: black;
            }

            .step.is-active h2{
                color: #818BF2;
                font-weight: 800;
            }

            .step h2 {
                text-align: center;
                padding: 2rem;
                font-size: 2rem;
            }
            
            .step p {
                padding: 0 2rem;
                font-size: 1.5rem;
            }

            * {
            box-sizing: border-box;
            }
            #layout {
                display: inline-flex;
                flex-wrap: wrap ;
            }
            .card {
                width: 400px;
                padding: 1em;
                margin: 1em;
                box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
                border-radius: 5px;
            }
            .collapsible {
                background-color: #eee;
                color: #444;
                cursor: pointer;
                width: 100%;
                border: none;
                text-align: left;
                outline: none;
                font-size: 15px;
                padding: 0 0.5em;
            }
            .active, .collapsible:hover {
                background-color: #ccc;
            }
            .content {
                display: none;
                overflow: hidden;
                background-color: #f1f1f1;
                margin-bottom: 1em;
                padding: 0.5em;
            }
            .collapsible:after {
                content: '\2304'; 
                font-size: 30px;
                color: #444;
                float: right;
                margin-left: 5px;
                line-height: 0.6em;
            }

            .active:after {
                content: "\2303"; 
                line-height: 1.6em;
            }
            #card-title{
                /* height: 70px; */
                font-size: 22px;
            }
            #card-footer {
                margin: 1em 0;
            }
            #tooltip{
                display: inline-block;
                background-color: white;
                font-size: 10;
                width: 150;
                max-height: 170;
                overflow-y: auto;
                overflow-wrap: break-word;
                padding: 1rem;
                /* border: 1px solid black; */
                box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
                border-radius: 5px;
            }
        </style>

        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://unpkg.com/d3-force-cluster@latest"></script>
        <script src="https://unpkg.com/scrollama"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-ease@3"></script>
    </head>
<body>

    <div id="content">
    <h1>Pro-Ana Communities</h1>
    <h2>Introduction</h2>
    <h2>Corpus and Methods</h2>
    <main>
        <section id="scrolly">
            <article>
                <div class="step" data-step="1">
                    <h2>How does topic modeling work?</h2>
                    <p>
                        Let's look at a post from our dataset as an example...
                    </p>
                </div>
                <div class="step" data-step="2">
                    <h2>Which topics are associated with this post?</h2>
                    <p>
                        Our model tells us that this post is associated with
                        a few topics, including two topics which both have the word
                        "weight" as one of their most probable words.
                    </p>
                </div>
                <div class="step" data-step="3">
                    <h2>Which topics are the most important?</h2>
                    <p>
                        And we can get a document-topic matrix which shows us
                        the proportional weights of each topic associated with that post.
                    </p>
                </div>
                <div class="step" data-step="4">
                    <h2>Which documents are the most representative of a given topic?</h2>
                    <p>
                        We can also reverse this and see which documents are most highly associated with
                        a given topic.
                    </p>
                </div>
                <div class="step" data-step="5">
                    <h2>Why should we care?</h2>
                    <p>
                        This helps us label common themes in these communities so that we can
                        better understand their needs.
                    </p>
                </div>
            </article>
    
            <figure>
                <img src="images/step1.svg"></img>
            </figure>
        </section>
    
        <section id="outro"></section>
    </main>

    <div id="layout">
        <div id="topic-0" class="container card">
            <div class="row">
                <h4 id="card-title">
                    ....
                </h4>
            </div>

            <div class="row" id="card-details">
                <p>Topic description here</p>
            </div>

            <!-- collapse: https://www.w3schools.com/howto/howto_js_collapsible.asp -->

            <div class="row" id="collapse">
                <button type="button" class="collapsible">See Top Words</button>
                <div class="content">
                    <p>Top words here...</p>
                    <svg id="topwords" width="355" height="200" style="border: 1px solid black; background-color:white"></svg>
                </div>
            </div>

            <div class="row" id="chart">
                <svg id="main" width="370" height="300" style="border: 1px solid black"></svg>
            </div>

            <div class="row" id="card-footer">
                <p>FOOTER CONTENT HERE</p>
            </div>
        </div>
    </div>
    </div>

    <script id="scroll">

        // using d3 for convenience
        var main = d3.select("main");
        var scrolly = main.select("#scrolly");
        var figure = scrolly.select("figure");
        var article = scrolly.select("article");
        var step = article.selectAll(".step");

        // initialize the scrollama
        var scroller = scrollama();

        var i=0

        // generic window resize listener event
        function handleResize() {
            // 1. update height of step elements
            var stepH = Math.floor(window.innerHeight * 0.55);
            step.style("height", stepH + "px");

            var figureHeight = window.innerHeight / 2;
            var figureMarginTop = (window.innerHeight - figureHeight) / 2;

            figure
                .style("height", figureHeight + "px")
                .style("top", figureMarginTop + "px");

            // 3. tell scrollama to update new element dimensions
            scroller.resize();
        }

        // scrollama event handlers
        function handleStepEnter(response) {
            console.log(response);
            i+=1
            console.log("enter",i)
            // response = { element, direction, index }

            // add color to current step only
            step.classed("is-active", function (d, i) {
                return i === response.index;
            });

            // update graphic based on step

            figure.select("img")
                .transition()
                .ease(d3.easeExpOut)
                .duration(100)
                .style("opacity", 0)
                .remove()

            figure.append("img")

            figure.select("img").attr("src", `images/step${response.index + 1}.svg`)

            figure.select("img").transition().ease(d3.easeExpIn).duration(100).style("opacity", 1)

        }

        function handleStepExit(response) {
            console.log(response);
            i -= 1
            console.log("exit", i)
            // response = { element, direction, index }

            figure.select("img")
                .transition()
                .ease(d3.easeExpOut)
                .duration(100)
                .style("opacity", 0)
                .remove()
        }

        function init() {

            // 1. force a resize on load to ensure proper dimensions are sent to scrollama
            handleResize();

            // 2. setup the scroller passing options
            // 		this will also initialize trigger observations
            // 3. bind scrollama event handlers (this can be chained like below)
            scroller
                .setup({
                    step: "#scrolly article .step",
                    offset: 0.33,
                    debug: false
                })
                .onStepEnter(handleStepEnter)
                // .onStepExit(handleStepExit);
        }

        // kick things off
        init();

    </script>

    <script id="cards">
    const requestData = async () => {
        full = await d3.csv("data/full_data.csv", d3.autoType)
        topWords = await d3.csv("data/top-words.csv", d3.autoType)
        
        console.log(full);
        console.log(topWords)

        // store cols w topic scores
        const topCol = new Array
        full.columns.forEach(d => {
            if(d.includes("topic")){
                topCol.push(d)
            }
        })

        // store data for scaling radius
        const radData = {'min': 1,
                        'max': 0,}

        topCol.forEach((top) => {

            var top0 = full.filter(function (d) {

                return d.dom_top === top;

            })

            // sort by group 
            let groups = d3.groups(top0, o => o.class)

            let sortedGroups = new Array

            groups.forEach((g) => {
                sortedGroups.push(g[1].sort(function (a, b) { return -a[top] - -b[top] })
                    .slice(0, 20))
            })

            let mergedGr = d3.merge(sortedGroups)

            let min = d3.min(mergedGr, d => d[top])
            let max = d3.max(mergedGr, d => d[top])

            if (radData['min']> min) radData['min']=min;
            if (radData['max']< max) radData['max']=max;

        })

        console.log(radData)
        
        // dict for text
        let textMap = {"topic-0": "TOPIC 1: DIET FOODS",
                       "topic-1": "TOPIC 2: SHAME FROM AN ED",
                       "topic-2": "TOPIC 3: SUPPORT AND EMPATHY",
                       "topic-3": "TOPIC 4: RECOVERY",
                       "topic-4": "TOPIC 5: LIVING WITH AN ED",
                       "topic-5": "TOPIC 6: HATRED OF BODY",
                       "topic-6": "TOPIC 7: CALORIE RESTRICTION",
                       "topic-7": "TOPIC 8: FEELING HUNGRY",
                       "topic-8": "TOPIC 9: TRIGGERS",
                       "topic-9": "TOPIC 10: GOAL WEIGHTS"
        }

        let chosenTopic = "topic-0"

        function updateText(chosenTopic){
            let cont = d3.select(`div#${chosenTopic}`)
            cont.select("h4#card-title").text(textMap[chosenTopic])
        }

        d3.select('body')
            .append('div')
            .attr('id', 'tooltip')
            .attr('style', 'position: absolute; opacity: 0;');

        d3.select('body').on('click', resetTooltip)

        function populateCard(chosenTopic, svg, topW) {

            let width = svg.attr("width")
            let height = svg.attr("height")
            const margins = { top: 10, right: 15, bottom: 30, left: 60 }
            const chartWidth = width - 10 - margins.right;
            const chartHeight = height - margins.top - 10;

            const topWidth = topW.attr("width")
            const topHeight = topW.attr("height")
            const topChartWidth = topWidth - margins.left - margins.right;
            const topChartHeight = topHeight - margins.top - margins.bottom;

            // see top words collapsible 
            let cont = d3.select(`div#${chosenTopic}`)
            let coll = cont.select("button.collapsible");
            coll.on("click", function () {
                this.classList.toggle("active");
                var content = cont.select("div.content")
                if (content.style("display") === "block") {
                    content.style("display", "none");
                    content.select("g#bars").remove()
                    
                } else {
                    content.style("display", "block");
                    loadBars();
                }

            });

            function loadBars(){
                // top words
                const wordArea = topW.append("g").attr("id", "bars")
                    .attr("transform", `translate(${margins.left}, ${margins.top})`)

                // Y axis
                let selectWords = topWords.filter(function (d) {
                    let top = parseInt(chosenTopic.slice(-1))
                    return d.topic == top
                })
                var y = d3.scaleBand()
                    .range([0, topChartHeight])
                    .domain(selectWords.map(function (d) { return d.word; }))
                    .padding(0.2);
                wordArea.append("g")
                    .call(d3.axisLeft(y).tickSize(0))
                    .selectAll("text")
                    // .attr("transform", "translate(-10,0)rotate(-45)")
                    .style("text-anchor", "end");

                // Add X axis
                var xExtent = d3.extent(selectWords, d => d['proba'])
                var x = d3.scaleLinear()
                    .domain([0, xExtent[1]])
                    .range([0, topChartWidth]);
                wordArea.append("g")
                    .attr("transform", "translate(0," + topChartHeight + ")")
                    .call(d3.axisBottom(x)
                        .ticks(4)
                        .tickSize(0)
                        .tickFormat(d3.format(".1%")));

                // color scale
                var barColor = d3.scaleSequential(d3.interpolateOrRd)
                    .domain(xExtent)

                // set font
                d3.selectAll("text").attr("font-family", "Roboto Mono")


                wordArea.selectAll("rects").data(selectWords)
                    .join("rect")
                    .attr("y", d => y(d['word']))
                    .attr("height", y.bandwidth())
                    .transition() // <---- Here is the transition
                    .duration(1000)
                    .attr("width", d => topChartWidth - y(d['word']))
                    .attr("x", d => x(0))
                    .attr("fill", d => barColor(d['proba']))

            }
            

            // update title and desc
            updateText(chosenTopic)

            var top0 = full.filter(function (d) {

                return d.dom_top === chosenTopic;

            })

            // sort by group 
            let groups = d3.groups(top0, o => o.class)

            let sortedGroups = new Array

            groups.forEach((g) => {
                sortedGroups.push(g[1].sort(function (a, b) { return -a[chosenTopic] - -b[chosenTopic] })
                    .slice(0, 20))
            })

            let mergedGr = d3.merge(sortedGroups)

            // d3 force cluster from https://gist.github.com/ericsoco/4e1b7b628771ae77753842e6dabfcef3

            var padding = 1.5, // separation between same-color nodes
                clusterPadding = 10, // separation between different-color nodes
                maxRadius = 13;

            var n = mergedGr.length, // total number of nodes
                m = 3; // number of distinct clusters

            var color = d3.scaleOrdinal()
                .domain(['edc', 'mpa', 'reddit'])
                .range(["cornflowerblue", "coral", "crimson"]);

            // The largest node for each cluster.
            var clusters = new Array(m);

            var nodesTest = new Array

            // new scale for radius
            var radExtent = [radData['min'], radData['max']]
            // const radExtent = d3.extent(mergedGr, d => d[chosenTopic])
            const radScale = d3.scaleSqrt().domain(radExtent).range([5, maxRadius])

            var mapping = { "edc": 1, "mpa": 2, "reddit": 3 }

            function getText(d) {
                return d.class != "reddit" ? d['post-text'] : d['body']
            }

            mergedGr.forEach(function (d) {
                var i = d['class'],
                    r = radScale(d[chosenTopic]),
                    d = {
                        cluster: i,
                        radius: r,
                        text: getText(d),
                        x: Math.cos(mapping[i] / m * 0.7 * Math.PI) * 140 + chartWidth / 2 ,
                        y: Math.sin(mapping[i] / m * 0.7 * Math.PI) * 140 + chartHeight / 2 
                    };
                if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
                nodesTest.push(d);
            })
            
            var simulation = d3.forceSimulation()
                // keep entire simulation balanced around screen center
                .force('center', d3.forceCenter(width / 2, height / 2))

                // cluster by section
                .force('cluster', d3.forceCluster()
                    .centers(function (d) { return clusters[d.cluster]; })
                    .strength(0.5))

                // apply collision with padding
                .force('collide', d3.forceCollide(function (d) { return d.radius + padding; }))

                .on('tick', layoutTick)
                .nodes(nodesTest);

            const chartArea = svg.append("g").attr("id", "force");

            var node = chartArea.selectAll('circle')
                .data(nodesTest)
                .enter().append('circle')
                .style('fill', d => color(d.cluster))
                .on("mouseover", hoverIn)
                .on("mouseout", hoverOut)
                .on("click", mouseClick)
                .on('mousemove', mouseMove);

            // legend
            chartArea.append("circle")
                     .attr("cx", 80)
                     .attr("cy", 20)
                     .attr("r", 6)
                     .style("fill", "crimson")
            chartArea.append("circle")
                     .attr("cx", 170)
                     .attr("cy", 20)
                     .attr("r", 6)
                     .style("fill", "coral")
            chartArea.append("circle")
                     .attr("cx", 240)
                     .attr("cy", 20)
                     .attr("r", 6)
                     .style("fill", "cornflowerblue")
            chartArea.append("text")
                     .attr("x", 90)
                     .attr("y", 20)
                     .text("Reddit")
                     .style("font-size", "15px")
                     .attr("alignment-baseline", "middle")
            chartArea.append("text")
                     .attr("x", 180)
                     .attr("y", 20)
                     .text("MPA")
                     .style("font-size", "15px")
                     .attr("alignment-baseline", "middle")
            chartArea.append("text")
                     .attr("x", 250)
                     .attr("y", 20)
                     .text("EDC")
                     .style("font-size", "15px")
                     .attr("alignment-baseline", "middle")


            function layoutTick(e) {
                node
                    .attr('cx', function (d) { return d.x; })
                    .attr('cy', function (d) { return d.y; })
                    .attr('r', function (d) { return d.radius; });
            }

            

        }
        populateCard(chosenTopic, d3.select("svg#main"), d3.select("svg#topwords"));


        topCol.slice(1).forEach(t => {

            // test html function
            let cont = d3.select("div#layout")
                .append("div")
                .attr("id", t)
                .attr("class", "container card")
                

            cont.html('<div class="row"><h4 id="card-title">....</h4></div>' +
                '<div class="row" id="card-details"><p>Topic description here</p></div>' +
                '<div class="row" id="collapse"><button type = "button" class= "collapsible">See Top Words</button>' +
                '<div class="content"><p>Top words here...</p><svg id="topwords" width="355" height="200" style="border: 1px solid black; background-color:white"></svg></div></div >' +
                '<div class="row" id="chart"><svg id = "main" width = "370" height = "300" style = "border: 1px solid black"></svg></div >' +
                '<div class="row" id="card-footer"><p>FOOTER CONTENT HERE</p></div>')
            
            populateCard(t, cont.select("svg#main"), cont.select("svg#topwords"))

        })
        


        function hoverIn(e,d){
            d3.select(this).style("stroke", "black").style("stroke-width", 2)
                
        }

        function hoverOut(){
            
            if(!d3.select(this).classed("active")){
                d3.select(this).style("stroke", "")
            }   
        }

        function mouseMove(e, d) {
            // d3.select('#tooltip')
            //     .style('left', (e.pageX + 10) + 'px').style('top', (e.pageY + 10) + 'px')
            //     .text(d.text)
            //     .transition()
            //     .duration(100)
            //     .ease(d3.easeCubicIn)
            //     .style('opacity', 1).text(d.text)
        }

        function mouseClick(e,d){

            d3.select(this).classed("active", true)

            let other = d3.selectAll("circle").filter(function(a){
                return a != d
            })

            other.classed("active", false).style("stroke", "")
                 
            
            d3.select('#tooltip')
                .style('left', (e.pageX) + 'px').style('top', (e.pageY + 10) + 'px')
                .text(d.text)
                .transition()
                .duration(100)
                .ease(d3.easeCubicIn)
                .style('opacity', 1)
                
                
            
        }

        function resetTooltip() {
            // reset tooltip state
            d3.select("#tooltip").style('opacity', 0)

            // d3.selectAll("circle").style("stroke", "")
        }

        



    }
    requestData();
    </script>
</body>
</html>